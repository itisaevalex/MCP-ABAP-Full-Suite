/// <reference types="node" />
/// <reference types="node" />
import { AxiosBasicCredentials, Method, AxiosResponseHeaders } from "axios";
import https from "https";
import { LogCallback } from ".";
export declare enum session_types {
    stateful = "stateful",
    stateless = "stateless",
    keep = ""
}
export interface HttpResponse {
    body: string;
}
export interface ClientOptions {
    headers?: Record<string, string>;
    httpsAgent?: https.Agent;
    baseURL?: string;
    debugCallback?: LogCallback;
    timeout?: number;
    auth?: AxiosBasicCredentials;
    keepAlive?: boolean;
}
export interface RequestOptions extends ClientOptions {
    method?: Method;
    headers?: Record<string, string>;
    httpsAgent?: https.Agent;
    qs?: Record<string, any>;
    baseURL?: string;
    timeout?: number;
    auth?: AxiosBasicCredentials;
    body?: string;
    url?: string;
}
export type BearerFetcher = () => Promise<string>;
export interface HttpClientResponse {
    body: string;
    status: number;
    statusText: string;
    headers: AxiosResponseHeaders;
    request?: any;
}
interface RequestMetadata {
    adtRequestNumber?: number;
    adtStartTime?: Date;
}
export interface HttpClientOptions extends RequestOptions, RequestMetadata {
    url: string;
}
/**
 * Abstract HTTP client
 * cookies, authentication and CSRF tokens usually handled by higher level intercacve
 */
export interface HttpClient {
    /**
     * HTTP request
     * @param options url, headers,...
     * @returns the result of the HTTP call
     *
     * expected to throw only AdtException errors
     */
    request: (options: HttpClientOptions) => Promise<HttpClientResponse>;
}
export declare class AxiosHttpClient implements HttpClient {
    private baseURL;
    private axios;
    constructor(baseURL: string, config?: ClientOptions);
    request(options: HttpClientOptions): Promise<HttpClientResponse>;
}
export declare class AdtHTTP {
    readonly username: string;
    readonly client: string;
    readonly language: string;
    readonly baseURL: string;
    readonly id: number;
    readonly password?: string;
    isClone: boolean;
    private currentSession;
    private _stateful;
    private needKeepalive;
    readonly keepAlive?: NodeJS.Timer;
    private commonHeaders;
    private bearer?;
    private getToken?;
    private auth?;
    private httpclient;
    private debugCallback?;
    private loginPromise?;
    get isStateful(): boolean;
    get stateful(): session_types;
    set stateful(value: session_types);
    get csrfToken(): string;
    set csrfToken(token: string);
    get loggedin(): boolean;
    constructor(baseURLOrClient: string | HttpClient, username: string, password: string | BearerFetcher, client: string, language: string, config?: ClientOptions);
    login(): Promise<any>;
    private cookie;
    ascookies(): string;
    logout(): Promise<void>;
    dropSession(): Promise<void>;
    request(url: string, config?: RequestOptions): Promise<HttpClientResponse>;
    private keep_session;
    private updateCookies;
    private logResponse;
    /**
     * HTTP request without automated login / retry
     *
     * @param url URL suffix
     * @param options request options
     */
    private _request;
}
export {};
//# sourceMappingURL=AdtHTTP.d.ts.map