"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateStateful = exports.ValidateObjectUrl = exports.adtException = exports.fromException = exports.isAdtException = exports.isHttpError = exports.isCsrfError = exports.isAdtError = exports.SAPRC = void 0;
const utilities_1 = require("./utilities");
const util_1 = require("util");
const ADTEXTYPEID = Symbol();
const CSRFEXTYPEID = Symbol();
const HTTPEXTYPEID = Symbol();
var SAPRC;
(function (SAPRC) {
    SAPRC["Success"] = "S";
    SAPRC["Info"] = "I";
    SAPRC["Warning"] = "W";
    SAPRC["Error"] = "E";
    SAPRC["CriticalError"] = "A";
    SAPRC["Exception"] = "X";
})(SAPRC = exports.SAPRC || (exports.SAPRC = {}));
const isResponse = (r) => !!r.statusCode;
class AdtErrorException extends Error {
    constructor(err, properties, type, message, parent, namespace, localizedMessage, response) {
        super();
        this.err = err;
        this.properties = properties;
        this.type = type;
        this.message = message;
        this.parent = parent;
        this.namespace = namespace;
        this.localizedMessage = localizedMessage;
        this.response = response;
    }
    get typeID() {
        return ADTEXTYPEID;
    }
    static create(errOrResponse, properties, type, message, parent, namespace, localizedMessage, response) {
        if (isResponse(errOrResponse)) {
            return this.create(errOrResponse.statusCode, properties, "", errOrResponse.statusMessage || "Unknown error in adt client", undefined, undefined, undefined, errOrResponse);
        }
        else {
            return new AdtErrorException(errOrResponse, properties, type, message, parent, namespace, localizedMessage, response);
        }
    }
}
// tslint:disable-next-line:max-classes-per-file
class AdtCsrfException extends Error {
    constructor(message, parent) {
        super();
        this.message = message;
        this.parent = parent;
    }
    get typeID() {
        return CSRFEXTYPEID;
    }
}
// tslint:disable-next-line:max-classes-per-file
class AdtHttpException extends Error {
    constructor(parent) {
        super();
        this.parent = parent;
    }
    get typeID() {
        return HTTPEXTYPEID;
    }
    get code() {
        const p = this.parent;
        return (p.response && p.response.status) || 0;
    }
    get message() {
        return this.parent.message;
    }
    get name() {
        return this.parent.name;
    }
}
function isAdtError(e) {
    return e.typeID === ADTEXTYPEID;
}
exports.isAdtError = isAdtError;
function isCsrfError(e) {
    return e.typeID === CSRFEXTYPEID;
}
exports.isCsrfError = isCsrfError;
function isHttpError(e) {
    return e.typeID === HTTPEXTYPEID;
}
exports.isHttpError = isHttpError;
function isAdtException(e) {
    return isAdtError(e) || isCsrfError(e) || isHttpError(e);
}
exports.isAdtException = isAdtException;
function fromException(errOrResp) {
    if (!isResponse(errOrResp) && !util_1.types.isNativeError(errOrResp))
        return AdtErrorException.create(500, {}, "Unknown error", `${errOrResp}`); // hopefully will never happen
    if (isAdtException(errOrResp))
        return errOrResp;
    try {
        if (isResponse(errOrResp)) {
            const response = errOrResp;
            if (!(response && response.body))
                return adtException(`Error ${response.statusCode}:${response.statusMessage}`);
            if (response.statusCode === 403 &&
                response.headers["x-csrf-token"] === "Required")
                return new AdtCsrfException(response.body);
            const raw = utilities_1.fullParse(response.body);
            const root = raw["exc:exception"];
            const getf = (base, idx) => (base ? base[idx] : "");
            const properties = {};
            utilities_1.xmlArray(root, "properties", "entry").forEach((p) => {
                properties[p["@_key"]] = `${p["#text"]}`.replace(/^\s+/, "").replace(/\s+$/, "");
            });
            return new AdtErrorException(response.statusCode, properties, root.type["@_id"], root.message["#text"], undefined, getf(root.namespace, "@_id"), getf(root.localizedMessage, "#text"));
        }
        else
            return new AdtHttpException(errOrResp);
    }
    catch (e) {
        return isResponse(errOrResp)
            ? AdtErrorException.create(errOrResp, {})
            : new AdtHttpException(errOrResp);
    }
}
exports.fromException = fromException;
function adtException(message) {
    return new AdtErrorException(0, {}, "", message);
}
exports.adtException = adtException;
function ValidateObjectUrl(url) {
    if (url.match(/^\/sap\/bc\/adt\/[a-z]+\/[a-zA-Z%\$]?[\w%]+/))
        return; // valid
    throw new AdtErrorException(0, {}, "BADOBJECTURL", "Invalid Object URL:" + url);
}
exports.ValidateObjectUrl = ValidateObjectUrl;
function ValidateStateful(h) {
    if (h.isStateful)
        return;
    throw new AdtErrorException(0, {}, "STATELESS", "This operation can only be performed in stateful mode");
}
exports.ValidateStateful = ValidateStateful;
