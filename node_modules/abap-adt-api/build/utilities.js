"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toXmlAttributes = exports.formatQS = exports.boolFromAbap = exports.followUrl = exports.parts = exports.btoa = exports.encodeEntity = exports.decodeEntity = exports.parseJsonDate = exports.toSapDate = exports.parseSapDate = exports.toInt = exports.fullParse = exports.xmlNodeAttr = exports.stripNs = exports.xmlRoot = exports.xmlArray = exports.xmlFlatArray = exports.xmlNode = exports.JSON2AbapXML = exports.isString = exports.isArray = exports.isObject = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const html_entities_1 = require("html-entities");
const isObject = (x) => !!x && typeof x === 'object';
exports.isObject = isObject;
const isArray = (x) => Array.isArray(x);
exports.isArray = isArray;
const isString = (x) => typeof (x) === "string";
exports.isString = isString;
function JSON2AbapXML(original, root = "DATA") {
    // only flat objects for now, might extend later...
    let inner = "";
    for (const key of Object.keys(original))
        if (original[key])
            inner = `${inner}\n<${key}>${exports.encodeEntity(original[key]) || ""}</${key}>`;
        else
            inner = `${inner}\n<${key}/>`;
    return `<?xml version="1.0" encoding="UTF-8"?><asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0">
    <asx:values>
      <${root}>
        ${inner}
      </${root}>
    </asx:values>
  </asx:abap>`;
}
exports.JSON2AbapXML = JSON2AbapXML;
function xmlNode(xml, ...path) {
    let current = xml;
    path.some(key => {
        // @ts-ignore
        if (exports.isObject(current))
            current = current[key];
        return !current;
    });
    return current;
}
exports.xmlNode = xmlNode;
function xmlFlatArray(xml, ...path) {
    if (!xml)
        return [];
    if (path.length === 0) {
        if (exports.isArray(xml))
            return xml;
        else
            return [xml];
    }
    if (exports.isArray(xml))
        return xml.reduce((arr, x) => [...arr, ...xmlFlatArray(x, ...path)], []);
    if (exports.isObject(xml)) {
        const [idx, ...rest] = path;
        // @ts-ignore
        return xmlFlatArray(xml[idx], ...rest);
    }
    return [];
}
exports.xmlFlatArray = xmlFlatArray;
function xmlArray(xml, ...path) {
    const node = xmlNode(xml, ...path);
    if (node) {
        if (exports.isArray(node))
            return node;
        else
            return [node];
    }
    return [];
}
exports.xmlArray = xmlArray;
const ok = Object.keys;
const xmlRoot = (o) => o[ok(o)[0]];
exports.xmlRoot = xmlRoot;
const stripNs = (x) => x &&
    ok(x).reduce((obj, key) => {
        const nk = key.split(":").slice(1).join(":") || key;
        if (nk in obj)
            obj[key] = key;
        else
            obj[nk] = x[key];
        return obj;
    }, {});
exports.stripNs = stripNs;
// extract XML attributes of a node from its JSON representation
const xmlNodeAttr = (n) => n &&
    ok(n)
        .filter(k => k.match(/^(?!@_xmlns)@_/))
        .reduce((part, cur) => {
        part[cur.replace(/^@_/, "")] = n[cur];
        return part;
    }, {});
exports.xmlNodeAttr = xmlNodeAttr;
const fullParse = (xml, options = {}) => fast_xml_parser_1.parse(xml, Object.assign({ ignoreAttributes: false, trimValues: false, parseAttributeValue: true }, options));
exports.fullParse = fullParse;
function toInt(x) {
    if (!x)
        return 0;
    if (x.match(/^\s*\d*\s*$/))
        return Number.parseInt(x, 10);
    return 0;
}
exports.toInt = toInt;
const parseSapDate = (d) => {
    const match = d.match(/(\d\d\d\d)(\d\d)(\d\d)/);
    if (!match)
        return new Date(); // wrong but valid
    const [Y, M, D] = match.slice(1);
    return Date.UTC(toInt(Y), toInt(M) - 1, toInt(D));
};
exports.parseSapDate = parseSapDate;
const toSapDate = (d) => d.getUTCFullYear() * 10000 + (d.getUTCMonth() + 1) * 100 + d.getUTCDate();
exports.toSapDate = toSapDate;
const parseJsonDate = (d) => new Date(Date.parse(d));
exports.parseJsonDate = parseJsonDate;
_a = (() => {
    let entities;
    return [
        (s) => {
            if (!entities)
                entities = new html_entities_1.AllHtmlEntities();
            return entities.decode(s);
        },
        (s) => {
            if (!entities)
                entities = new html_entities_1.AllHtmlEntities();
            return entities.encode(s);
        }
    ];
})(), exports.decodeEntity = _a[0], exports.encodeEntity = _a[1];
function btoa(s) {
    return Buffer.from(s).toString("base64");
}
exports.btoa = btoa;
function parts(whole, pattern) {
    if (!exports.isString(whole))
        return [];
    const match = whole.match(pattern);
    return match ? match.slice(1) : [];
}
exports.parts = parts;
const followUrl = (base, extra) => {
    if (extra.match(/^\.\//)) {
        base = base.replace(/[^\/]*$/, "");
        extra = extra.replace(/^\.\//, "");
    }
    else
        extra = extra.replace(/^\//, "");
    base = base.replace(/\/$/, "");
    return base + "/" + extra;
};
exports.followUrl = followUrl;
const boolFromAbap = (x) => x === "X";
exports.boolFromAbap = boolFromAbap;
function formatQS(raw) {
    const val = (key, x) => exports.isArray(x)
        ? x.map(e => val(key, e)).join("&")
        : `${key}=${encodeURIComponent(x)}`;
    return Object.getOwnPropertyNames(raw)
        .map(k => val(k, raw[k]))
        .join("&");
}
exports.formatQS = formatQS;
const toXmlAttributes = (o, prefix) => {
    const sep = prefix ? ":" : "";
    return o
        ? Object.getOwnPropertyNames(o)
            .sort()
            .map(k => `${prefix}${sep}${k.replace(/^@_/, "")}="${o[k]}"`)
            .join(" ")
        : "";
};
exports.toXmlAttributes = toXmlAttributes;
