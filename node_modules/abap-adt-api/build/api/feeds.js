"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dumps = exports.feeds = void 0;
const utilities_1 = require("../utilities");
const parseFeeds = (body) => {
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true });
    const parseDt = (dt) => {
        const { "@_id": id, label = "" } = dt;
        const operators = utilities_1.xmlArray(dt, "operators", "operator");
        return { id, label, operators: operators.map((o) => o["@_id"]) };
    };
    const parseAttribute = (at) => {
        var _a;
        const dataType = (_a = at.dataType) === null || _a === void 0 ? void 0 : _a["@_id"];
        return Object.assign(Object.assign({}, parseDt(at)), { dataType });
    };
    const parseOperators = (op) => (Object.assign(Object.assign({}, utilities_1.xmlNodeAttr(op)), { label: op.label }));
    const feeds = utilities_1.xmlArray(raw, "feed", "entry").map((f) => {
        var _a, _b;
        const author = utilities_1.xmlNode(f, "author", "name");
        const { href, type: accept } = utilities_1.xmlNodeAttr(f["link"]);
        const { published, summary, title, updated } = f;
        const ed = f.extendedData;
        const refresh = utilities_1.xmlNodeAttr((_a = ed === null || ed === void 0 ? void 0 : ed.refresh) === null || _a === void 0 ? void 0 : _a.interval);
        const paging = (_b = ed === null || ed === void 0 ? void 0 : ed.paging) === null || _b === void 0 ? void 0 : _b['@_size'];
        const { queryIsObligatory, queryDepth } = ed;
        const operators = utilities_1.xmlArray(ed, "operators", "operator").map(parseOperators);
        const dataTypes = utilities_1.xmlArray(ed, "dataTypes", "dataType").map(parseDt);
        const attributes = utilities_1.xmlArray(ed, "attributes", "attribute").map(parseAttribute);
        const queryVariants = utilities_1.xmlArray(ed, "queryVariants", "queryVariant").map(utilities_1.xmlNodeAttr);
        return {
            author, href, published: utilities_1.parseJsonDate(published), summary, title, updated: utilities_1.parseJsonDate(updated), accept, refresh, paging,
            operators, dataTypes, attributes,
            queryIsObligatory, queryDepth, queryVariants
        };
    });
    return feeds;
};
const parseDumps = (body) => {
    var _a;
    const raw = (_a = utilities_1.fullParse(body, { ignoreNameSpace: true })) === null || _a === void 0 ? void 0 : _a.feed;
    const { href } = utilities_1.xmlNodeAttr(raw === null || raw === void 0 ? void 0 : raw.link);
    const { title, updated } = raw;
    const dumps = utilities_1.xmlArray(raw, "entry").map((e) => {
        const { category, id, author: { name: author }, summary: { "#text": text, "@_type": type } } = e;
        const links = utilities_1.xmlArray(e, "link").map(utilities_1.xmlNodeAttr);
        return { categories: category.map(utilities_1.xmlNodeAttr), links, id, author, text: utilities_1.decodeEntity(text), type };
    });
    return { href, title, updated: utilities_1.parseJsonDate(updated), dumps };
};
function feeds(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/atom+xml;type=feed" };
        const response = yield h.request("/sap/bc/adt/feeds", { method: "GET", headers });
        return parseFeeds(response.body);
    });
}
exports.feeds = feeds;
function dumps(h, query = "") {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/atom+xml;type=feed" };
        const qs = {};
        if (query)
            qs["$query"] = query;
        const response = yield h.request("/sap/bc/adt/runtime/dumps", { method: "GET", qs, headers });
        return parseDumps(response.body);
    });
}
exports.dumps = dumps;
