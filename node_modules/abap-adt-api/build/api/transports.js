"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransportConfiguration = exports.transportConfigurations = exports.transportReference = exports.systemUsers = exports.transportAddUser = exports.transportSetOwner = exports.transportRelease = exports.transportDelete = exports.setTransportsConfig = exports.createTransportsConfig = exports.transportsByConfig = exports.userTransports = exports.createTransport = exports.transportInfo = exports.TransportDateFilter = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const AdtException_1 = require("../AdtException");
const utilities_1 = require("../utilities");
var TransportDateFilter;
(function (TransportDateFilter) {
    TransportDateFilter[TransportDateFilter["SinceYesterday"] = 0] = "SinceYesterday";
    TransportDateFilter[TransportDateFilter["SincleTwoWeeks"] = 1] = "SincleTwoWeeks";
    TransportDateFilter[TransportDateFilter["SinceFourWeeks"] = 2] = "SinceFourWeeks";
    TransportDateFilter[TransportDateFilter["DateRange"] = 3] = "DateRange";
})(TransportDateFilter = exports.TransportDateFilter || (exports.TransportDateFilter = {}));
function extractLocks(raw) {
    const lock = raw && raw.CTS_OBJECT_LOCK;
    if (!lock)
        return;
    try {
        const holder = lock.LOCK_HOLDER;
        const TASKS = utilities_1.xmlArray(holder, "TASK_HEADERS").map((x) => x.CTS_TASK_HEADER);
        return {
            HEADER: holder.REQ_HEADER,
            OBJECT_KEY: utilities_1.xmlNode(lock, "OBJECT_KEY"),
            TASKS
        };
    }
    catch (_a) {
        return;
    }
}
function extractTransports(raw) {
    return utilities_1.xmlArray(raw, "CTS_REQUEST").map((x) => x.REQ_HEADER);
}
function transportInfo(h, URI, DEVCLASS = "", OPERATION = "I") {
    return __awaiter(this, void 0, void 0, function* () {
        AdtException_1.ValidateObjectUrl(URI);
        const body = utilities_1.JSON2AbapXML({
            DEVCLASS,
            OPERATION,
            URI
        });
        const headers = {
            Accept: "application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.transport.service.checkData",
            "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.transport.service.checkData"
        };
        const response = yield h.request("/sap/bc/adt/cts/transportchecks", {
            body,
            method: "POST",
            headers
        });
        // return parsePackageResponse(response.body)
        // tslint:disable-next-line: prefer-const
        let _a = fast_xml_parser_1.parse(response.body)["asx:abap"]["asx:values"].DATA, { REQUESTS, LOCKS, MESSAGES } = _a, header = __rest(_a, ["REQUESTS", "LOCKS", "MESSAGES"]);
        if (MESSAGES) {
            MESSAGES = utilities_1.xmlArray(MESSAGES, "CTS_MESSAGE").map((m) => {
                // tslint:disable-next-line: prefer-const
                let { VARIABLES } = m, rest = __rest(m, ["VARIABLES"]);
                VARIABLES =
                    (VARIABLES && utilities_1.xmlArray(m, "VARIABLES", "CTS_VARIABLE")).map((v) => v.VARIABLE) || [];
                return Object.assign({ VARIABLES }, rest);
            });
            MESSAGES.filter((m) => m.SEVERITY.match(/[EAX]/)).some((e) => {
                throw AdtException_1.adtException(e.TEXT);
            });
        }
        const TRANSPORTS = extractTransports(REQUESTS);
        return Object.assign(Object.assign({}, header), { LOCKS: extractLocks(LOCKS), TRANSPORTS });
    });
}
exports.transportInfo = transportInfo;
function createTransport(h, REF, REQUEST_TEXT, DEVCLASS, OPERATION = "I", transportLayer = "") {
    return __awaiter(this, void 0, void 0, function* () {
        AdtException_1.ValidateObjectUrl(REF);
        const body = utilities_1.JSON2AbapXML({ DEVCLASS, REQUEST_TEXT, REF, OPERATION });
        const qs = transportLayer ? { transportLayer } : {};
        const response = yield h.request("/sap/bc/adt/cts/transports", {
            body,
            qs,
            headers: {
                Accept: "text/plain",
                "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.CreateCorrectionRequest"
            },
            method: "POST"
        });
        const transport = response.body.split("/").pop();
        return transport;
    });
}
exports.createTransport = createTransport;
const parseTask = (t) => {
    const task = Object.assign(Object.assign({}, utilities_1.xmlNodeAttr(t)), { links: utilities_1.xmlArray(t, "atom:link").map(utilities_1.xmlNodeAttr), objects: utilities_1.xmlArray(t, "tm:abap_object").map(utilities_1.xmlNodeAttr) });
    if (task["tm:desc"])
        task["tm:desc"] = utilities_1.decodeEntity(task["tm:desc"]);
    return task;
};
const parseRequest = (r) => {
    const request = Object.assign(Object.assign({}, parseTask(r)), { tasks: utilities_1.xmlArray(r, "tm:task").map(parseTask) });
    return request;
};
const parseTargets = (s) => (Object.assign(Object.assign({}, utilities_1.xmlNodeAttr(s)), { modifiable: utilities_1.xmlArray(s, "tm:modifiable", "tm:request").map(parseRequest), released: utilities_1.xmlArray(s, "tm:released", "tm:request").map(parseRequest) }));
function userTransports(h, user, targets = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield h.request("/sap/bc/adt/cts/transportrequests", {
            qs: { user, targets }
        });
        const raw = utilities_1.fullParse(response.body);
        const workbench = utilities_1.xmlArray(raw, "tm:root", "tm:workbench", "tm:target").map(parseTargets);
        const customizing = utilities_1.xmlArray(raw, "tm:root", "tm:customizing", "tm:target").map(parseTargets);
        const retval = { workbench, customizing };
        return retval;
    });
}
exports.userTransports = userTransports;
function transportsByConfig(h, configUri, targets = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield h.request("/sap/bc/adt/cts/transportrequests", {
            qs: { configUri, targets }
        });
        const raw = utilities_1.fullParse(response.body);
        const workbench = utilities_1.xmlArray(raw, "tm:root", "tm:workbench", "tm:target").map(parseTargets);
        const customizing = utilities_1.xmlArray(raw, "tm:root", "tm:customizing", "tm:target").map(parseTargets);
        const retval = { workbench, customizing };
        return retval;
    });
}
exports.transportsByConfig = transportsByConfig;
const serializeTransportConfig = (cfg) => {
    const w = (k, v) => `<configuration:property key="${k}">${v}</configuration:property>`;
    const p = (v, k) => w(k, v[k]);
    const td = (d) => `${utilities_1.toSapDate(new Date(d))}`;
    const datelimit = cfg.DateFilter === TransportDateFilter.DateRange ?
        `${w("FromDate", td(cfg.FromDate))}${w("ToDate", td(cfg.ToDate))}` : "";
    return "".concat(`<configuration:configuration xmlns:configuration="http://www.sap.com/adt/configuration"> <configuration:properties>`, p(cfg, "WorkbenchRequests"), p(cfg, "CustomizingRequests"), p(cfg, "TransportOfCopies"), p(cfg, "DateFilter"), p(cfg, "Modifiable"), p(cfg, "Released"), p(cfg, "User"), datelimit, `</configuration:properties> </configuration:configuration>`);
};
function createTransportsConfig(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { "Accept": "application/vnd.sap.adt.configuration.v1+xml" };
        const uri = "/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations";
        const response = yield h.request(uri, { method: "POST", headers });
        return parseTransportConfig(response.body);
    });
}
exports.createTransportsConfig = createTransportsConfig;
function setTransportsConfig(h, uri, etag, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = serializeTransportConfig(config);
        const headers = {
            "Accept": "application/vnd.sap.adt.configuration.v1+xml",
            "Content-Type": "application/vnd.sap.adt.configuration.v1+xml",
            "If-Match": etag
        };
        const response = yield h.request(uri, { method: "PUT", headers, body });
        return parseTransportConfig(response.body);
    });
}
exports.setTransportsConfig = setTransportsConfig;
function validateTransport(transportNumber) {
    if (transportNumber.length !== 10 || !transportNumber.match(/^[a-z]\w\wk/i))
        AdtException_1.adtException("Invalid transport number:" + transportNumber);
}
function transportDelete(h, transportNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        validateTransport(transportNumber);
        yield h.request("/sap/bc/adt/cts/transportrequests/" + transportNumber, {
            method: "DELETE",
            headers: { Accept: "application/*" }
        });
    });
}
exports.transportDelete = transportDelete;
function transportRelease(h, transportNumber, ignoreLocks = false, IgnoreATC = false) {
    return __awaiter(this, void 0, void 0, function* () {
        validateTransport(transportNumber);
        const action = IgnoreATC
            ? "relObjigchkatc"
            : ignoreLocks
                ? "relwithignlock"
                : "newreleasejobs";
        const response = yield h.request(`/sap/bc/adt/cts/transportrequests/${transportNumber}/${action}`, {
            method: "POST",
            headers: { Accept: "application/*" }
        });
        const raw = utilities_1.fullParse(response.body);
        const reports = utilities_1.xmlArray(raw, "tm:root", "tm:releasereports", "chkrun:checkReport").map((r) => {
            return Object.assign(Object.assign({}, utilities_1.xmlNodeAttr(r)), { messages: utilities_1.xmlArray(r, "chkrun:checkMessageList", "chkrun:checkMessage").map(utilities_1.xmlNodeAttr) });
        });
        return reports;
    });
}
exports.transportRelease = transportRelease;
function transportSetOwner(h, transportNumber, targetuser) {
    return __awaiter(this, void 0, void 0, function* () {
        validateTransport(transportNumber);
        const response = yield h.request("/sap/bc/adt/cts/transportrequests/" + transportNumber, {
            method: "PUT",
            headers: { Accept: "application/*" },
            qs: { targetuser }
        });
        const raw = utilities_1.fullParse(response.body);
        return utilities_1.xmlNodeAttr(utilities_1.xmlNode(raw, "tm:root"));
    });
}
exports.transportSetOwner = transportSetOwner;
function transportAddUser(h, transportNumber, user) {
    return __awaiter(this, void 0, void 0, function* () {
        validateTransport(transportNumber);
        const body = `<?xml version="1.0" encoding="ASCII"?>
  <tm:root xmlns:tm="http://www.sap.com/cts/adt/tm" tm:number="${transportNumber}"
  tm:targetuser="${user}" tm:useraction="newtask"/>`;
        const response = yield h.request("/sap/bc/adt/cts/transportrequests/" + transportNumber + "/tasks", {
            method: "POST",
            body,
            headers: { Accept: "application/*", "Content-Type": "text/plain" }
        });
        const raw = utilities_1.fullParse(response.body);
        return utilities_1.xmlNodeAttr(utilities_1.xmlNode(raw, "tm:root"));
    });
}
exports.transportAddUser = transportAddUser;
function systemUsers(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield h.request("/sap/bc/adt/system/users", {
            headers: { Accept: "application/atom+xml;type=feed" }
        });
        const raw = fast_xml_parser_1.parse(response.body);
        return utilities_1.xmlArray(raw, "atom:feed", "atom:entry").map((r) => ({ id: r["atom:id"], title: r["atom:title"] }));
    });
}
exports.systemUsers = systemUsers;
// tslint:disable: variable-name
function transportReference(h, pgmid, obj_wbtype, obj_name) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield h.request("/sap/bc/adt/cts/transportrequests/reference", {
            headers: { Accept: "application/*" },
            qs: { obj_name, obj_wbtype, pgmid }
        });
        const raw = utilities_1.fullParse(response.body);
        const link = utilities_1.xmlNodeAttr(utilities_1.xmlNode(raw, "tm:root", "atom:link"));
        return link.href;
    });
}
exports.transportReference = transportReference;
const parseTransportConfigItemList = (body) => {
    const raw = utilities_1.fullParse(body, { parseAttributeValue: false });
    return utilities_1.xmlArray(raw, "configurations:configurations", "configuration:configuration").map((conf) => {
        const { "atom:link": { "@_href": link, "@_etag": etag } } = conf, rest = __rest(conf, ["atom:link"]);
        const _a = utilities_1.xmlNodeAttr(rest), { createdAt, changedAt } = _a, attrs = __rest(_a, ["createdAt", "changedAt"]);
        const item = Object.assign(Object.assign({}, attrs), { link, etag, createdAt: Date.parse(createdAt), changedAt: Date.parse(changedAt) });
        return item;
    });
};
function transportConfigurations(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/vnd.sap.adt.configurations.v1+xml" };
        const url = "/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations";
        const response = yield h.request(url, { headers });
        return parseTransportConfigItemList(response.body);
    });
}
exports.transportConfigurations = transportConfigurations;
const parseTransportConfig = (r) => {
    const raw = utilities_1.fullParse(r, { parseAttributeValue: false });
    const props = utilities_1.xmlArray(raw, "configuration:configuration", "configuration:properties", "configuration:property")
        .map((p) => {
        return { key: p["@_key"], value: p["#text"] };
    });
    const cfg = {};
    for (const { key, value } of props)
        cfg[key] = value;
    const WorkbenchRequests = cfg.WorkbenchRequests;
    const TransportOfCopies = cfg.TransportOfCopies;
    const Released = cfg.Released;
    const User = cfg.User;
    const CustomizingRequests = cfg.CustomizingRequests;
    const FromDate = cfg.FromDate && utilities_1.parseSapDate(`${cfg.FromDate}`);
    const ToDate = cfg.ToDate && utilities_1.parseSapDate(`${cfg.ToDate}`);
    const DateFilter = cfg.DateFilter;
    const Modifiable = cfg.Modifiable;
    return {
        WorkbenchRequests,
        TransportOfCopies,
        Released,
        User,
        CustomizingRequests,
        FromDate,
        ToDate,
        DateFilter,
        Modifiable
    };
};
function getTransportConfiguration(h, url) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/vnd.sap.adt.configuration.v1+xml" };
        const response = yield h.request(url, { headers });
        return parseTransportConfig(response.body);
    });
}
exports.getTransportConfiguration = getTransportConfiguration;
