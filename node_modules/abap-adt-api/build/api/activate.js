"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inactiveObjects = exports.inactiveObjectsInResults = exports.mainPrograms = exports.activate = void 0;
const util_1 = require("util");
const AdtException_1 = require("../AdtException");
const utilities_1 = require("../utilities");
function toElement(source) {
    if (!source || !source["ioc:ref"])
        return undefined;
    return Object.assign({ deleted: source["@_ioc:deleted"], user: source["@_ioc:user"] }, utilities_1.xmlNodeAttr(source["ioc:ref"]));
}
function parseInactive(raw) {
    return utilities_1.xmlArray(raw, "ioc:inactiveObjects", "ioc:entry").map((obj) => {
        return {
            object: toElement(utilities_1.xmlNode(obj, "ioc:object")),
            transport: toElement(utilities_1.xmlNode(obj, "ioc:transport"))
        };
    });
}
function activate(h, objectNameOrObjects, objectUrlOrPreauditReq = true, mainInclude, preauditRequested = true) {
    return __awaiter(this, void 0, void 0, function* () {
        let objects = [];
        let incl = "";
        if (util_1.isString(objectNameOrObjects)) {
            if (!util_1.isString(objectUrlOrPreauditReq))
                throw AdtException_1.adtException("Invalid parameters, objectUrl should be  a string");
            AdtException_1.ValidateObjectUrl(objectUrlOrPreauditReq || "");
            if (mainInclude)
                incl = `?context=${encodeURIComponent(mainInclude)}`;
            objects.push(`<adtcore:objectReference adtcore:uri="${objectUrlOrPreauditReq}${incl}" adtcore:name="${objectNameOrObjects}"/>`);
        }
        else {
            let inactives;
            if (util_1.isString(objectUrlOrPreauditReq))
                throw AdtException_1.adtException("Invalid parameters, preauditRequested should be a boolean");
            preauditRequested = objectUrlOrPreauditReq;
            if (util_1.isArray(objectNameOrObjects)) {
                inactives = objectNameOrObjects;
            }
            else
                inactives = [objectNameOrObjects];
            inactives.forEach(i => AdtException_1.ValidateObjectUrl(i["adtcore:uri"]));
            objects = inactives.map(i => `<adtcore:objectReference adtcore:uri="${i["adtcore:uri"]}" adtcore:type="${i["adtcore:type"]}" adtcore:parentUri="${i["adtcore:parentUri"]}" adtcore:name="${i["adtcore:name"]}"/>`);
        }
        const qs = { method: "activate", preauditRequested };
        const body = `<?xml version="1.0" encoding="UTF-8"?>` +
            `<adtcore:objectReferences xmlns:adtcore="http://www.sap.com/adt/core">` +
            objects.join(`\n`) +
            `</adtcore:objectReferences>`;
        const response = yield h.request("/sap/bc/adt/activation", {
            body,
            method: "POST",
            qs
        });
        let messages = [];
        let success = true;
        let inactive = [];
        if (response.body) {
            const raw = utilities_1.fullParse(response.body);
            inactive = parseInactive(raw);
            messages = utilities_1.xmlArray(raw, "chkl:messages", "msg").map((m) => {
                const message = utilities_1.xmlNodeAttr(m);
                message.shortText = (m.shortText && m.shortText.txt) || "Syntax error";
                return message;
            });
            if (inactive.length > 0)
                success = false;
            else
                messages.some(m => {
                    if (m.type.match(/[EAX]/))
                        success = false;
                    return !success;
                });
        }
        return { messages, success, inactive };
    });
}
exports.activate = activate;
function mainPrograms(h, IncludeUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        AdtException_1.ValidateObjectUrl(IncludeUrl);
        const response = yield h.request(`${IncludeUrl}/mainprograms`);
        const parsed = utilities_1.fullParse(response.body);
        const includes = utilities_1.xmlArray(parsed["adtcore:objectReferences"], "adtcore:objectReference").map(utilities_1.xmlNodeAttr);
        return includes;
    });
}
exports.mainPrograms = mainPrograms;
function inactiveObjectsInResults(results) {
    const obj = results.inactive.filter(x => x.object).map(x => x.object);
    return obj.map(o => {
        const _a = o, { user, deleted } = _a, rest = __rest(_a, ["user", "deleted"]);
        return rest;
    });
}
exports.inactiveObjectsInResults = inactiveObjectsInResults;
function inactiveObjects(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {
            Accept: "application/vnd.sap.adt.inactivectsobjects.v1+xml, application/xml;q=0.8"
        };
        const response = yield h.request("/sap/bc/adt/activation/inactiveobjects", {
            headers
        });
        return parseInactive(utilities_1.fullParse(response.body));
    });
}
exports.inactiveObjects = inactiveObjects;
