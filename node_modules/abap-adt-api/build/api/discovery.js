"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectTypes = exports.adtCompatibilityGraph = exports.adtCoreDiscovery = exports.adtDiscovery = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const utilities_1 = require("../utilities");
function adtDiscovery(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield h.request("/sap/bc/adt/discovery");
        const ret = utilities_1.fullParse(response.body);
        const objects = utilities_1.xmlArray(ret, "app:service", "app:workspace").map((o) => {
            return {
                collection: utilities_1.xmlArray(o, "app:collection").map((c) => {
                    return {
                        href: c["@_href"],
                        templateLinks: utilities_1.xmlArray(c, "adtcomp:templateLinks", "adtcomp:templateLink").map(utilities_1.xmlNodeAttr),
                        title: c["atom:title"]
                    };
                }),
                title: o["atom:title"]
            };
        });
        return objects;
    });
}
exports.adtDiscovery = adtDiscovery;
function adtCoreDiscovery(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield h.request("/sap/bc/adt/core/discovery");
        const ret = utilities_1.fullParse(response.body);
        const workspaces = utilities_1.xmlArray(ret, "app:service", "app:workspace").filter((w) => w["app:collection"]);
        return workspaces.map((w) => {
            const collection = w["app:collection"];
            return {
                collection: {
                    category: collection["atom:category"]["@_term"],
                    href: collection["@_href"],
                    title: collection["atom:title"]
                },
                title: w["atom:title"]
            };
        });
    });
}
exports.adtCoreDiscovery = adtCoreDiscovery;
function adtCompatibilityGraph(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield h.request("/sap/bc/adt/compatibility/graph");
        const ret = utilities_1.fullParse(response.body);
        const edges = utilities_1.xmlArray(ret, "compatibility:graph", "edges", "edge").map((e) => {
            return {
                sourceNode: utilities_1.xmlNodeAttr(e.sourceNode),
                targetNode: utilities_1.xmlNodeAttr(e.targetNode)
            };
        });
        const nodes = utilities_1.xmlArray(ret, "compatibility:graph", "nodes", "node").map(utilities_1.xmlNodeAttr);
        return { edges, nodes };
    });
}
exports.adtCompatibilityGraph = adtCompatibilityGraph;
function objectTypes(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const qs = { maxItemCount: 999, name: "*", data: "usedByProvider" };
        const response = yield h.request("/sap/bc/adt/repository/informationsystem/objecttypes", { qs });
        const ret = fast_xml_parser_1.parse(response.body);
        const types = utilities_1.xmlArray(ret, "nameditem:namedItemList", "nameditem:namedItem")
            .map((n) => {
            const data = n["nameditem:data"] || "";
            const fields = data.split(";").reduce((acc, cur) => {
                const parts = cur.split(":", 2);
                acc[parts[0]] = parts[1] || "";
                return acc;
            }, {});
            let o;
            if (fields.type && fields.usedBy)
                o = {
                    name: n["nameditem:name"],
                    description: n["nameditem:description"],
                    type: fields.type,
                    usedBy: fields.usedBy.split(",")
                };
            return o;
        })
            .filter(x => x);
        return types;
    });
}
exports.objectTypes = objectTypes;
