"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.debuggerSetVariableValue = exports.debuggerGoToStackOld = exports.debuggerGoToStack = exports.debuggerStep = exports.debuggerVariables = exports.debuggerChildVariables = exports.simpleDebuggerStack = exports.debuggerStack = exports.debuggerSaveSettings = exports.debuggerAttach = exports.debuggerDeleteBreakpoints = exports.debuggerSetBreakpoints = exports.isDebuggerBreakpoint = exports.debuggerDeleteListener = exports.debuggerListen = exports.debuggerListeners = exports.isDebuggee = exports.isDebugListenerError = exports.debugMetaIsComplex = void 0;
const __1 = require("..");
const utilities_1 = require("../utilities");
const urlparser_1 = require("./urlparser");
const debugMetaIsComplex = (m) => !["simple", "string", "boxedcomp", "anonymcomp", "unknown"].find(e => e === m);
exports.debugMetaIsComplex = debugMetaIsComplex;
const parseStep = (body) => {
    var _a;
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true });
    checkException(raw);
    const attrs = utilities_1.xmlNodeAttr(raw.step);
    const settings = utilities_1.xmlNodeAttr((_a = raw === null || raw === void 0 ? void 0 : raw.step) === null || _a === void 0 ? void 0 : _a.settings);
    const actions = utilities_1.xmlArray(raw, "step", "actions", "action").map(utilities_1.xmlNodeAttr);
    return Object.assign(Object.assign({}, attrs), { actions, settings });
};
const convertVariable = (v) => (Object.assign(Object.assign({}, v), { TABLE_LINES: utilities_1.toInt(v.TABLE_LINES), LENGTH: utilities_1.toInt(v.LENGTH), INHERITANCE_LEVEL: utilities_1.toInt(v.INHERITANCE_LEVEL), VALUE: utilities_1.decodeEntity(v.VALUE), ID: utilities_1.decodeEntity(v.ID), NAME: utilities_1.decodeEntity(v.NAME) }));
const parseVariables = (body) => {
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true, parseNodeValue: false, parseTrueNumberOnly: true });
    const variables = utilities_1.xmlArray(raw, "abap", "values", "DATA", "STPDA_ADT_VARIABLE")
        .map(convertVariable);
    return variables;
};
const parseChildVariables = (body) => {
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true, parseNodeValue: false, parseTrueNumberOnly: true });
    const hierarchies = utilities_1.xmlArray(raw, "abap", "values", "DATA", "HIERARCHIES", "STPDA_ADT_VARIABLE_HIERARCHY");
    const variables = utilities_1.xmlArray(raw, "abap", "values", "DATA", "VARIABLES", "STPDA_ADT_VARIABLE")
        .map(convertVariable);
    return { hierarchies, variables };
};
const parseStack = (body) => {
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true });
    const stack = utilities_1.xmlArray(raw, "stack", "stackEntry")
        .map(utilities_1.xmlNodeAttr)
        .map(x => (Object.assign(Object.assign({}, x), { uri: urlparser_1.parseUri(x.uri) })));
    const attrs = utilities_1.xmlNodeAttr(raw.stack);
    return Object.assign(Object.assign({}, attrs), { stack });
};
const parseDebugSettings = (body) => {
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true });
    return utilities_1.xmlNodeAttr(raw.settings);
};
const parseAttach = (body) => {
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true });
    const attrs = utilities_1.xmlNodeAttr(raw.attach);
    const reachedBreakpoints = utilities_1.xmlArray(raw, "attach", "reachedBreakpoints", "breakpoint").map(utilities_1.xmlNodeAttr);
    const actions = utilities_1.xmlArray(raw, "attach", "actions", "action").map(utilities_1.xmlNodeAttr);
    return Object.assign(Object.assign({}, attrs), { actions, reachedBreakpoints });
};
const parseBreakpoints = (body) => {
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true });
    return utilities_1.xmlArray(raw, "breakpoints", "breakpoint")
        .map(utilities_1.xmlNodeAttr)
        .map(x => {
        if (x.uri)
            return Object.assign(Object.assign({}, x), { uri: urlparser_1.parseUri(x.uri) });
        return x;
    });
};
const parseDebugError = (raw) => {
    if (raw.exception) {
        const { namespace: { "@_id": namespace }, type: { "@_id": type }, localizedMessage, message } = raw.exception;
        const parseMessage = (m) => ({ text: m["#text"], lang: m["@_lang"] });
        const entries = {};
        for (const ex of utilities_1.xmlArray(raw.exception, "properties", "entry"))
            entries[ex["@_key"]] = ex["#text"];
        return Object.assign(Object.assign({}, entries), { namespace,
            type, message: parseMessage(message), localizedMessage: parseMessage(localizedMessage) });
    }
};
const checkException = (raw) => {
    const e = parseDebugError(raw);
    if (e) {
        const err = new Error(e.message.text);
        err.extra = e;
        throw err;
    }
};
const isDebugListenerError = (e) => !!e && "conflictText" in e && "com.sap.adt.communicationFramework.subType" in e;
exports.isDebugListenerError = isDebugListenerError;
const isDebuggee = (d) => !!d && !["CLIENT", "DEBUGGEE_ID", "TERMINAL_ID", "IDE_ID", "DEBUGGEE_USER"].find(f => !(f in d));
exports.isDebuggee = isDebuggee;
const parseDebugListeners = (body) => {
    if (!body)
        return;
    const raw = utilities_1.fullParse(body, { ignoreNameSpace: true });
    const err = parseDebugError(raw);
    if (err)
        return err;
    const debug = utilities_1.xmlNode(raw, "abap", "values", "DATA", "STPDA_DEBUGGEE");
    return Object.assign(Object.assign({}, debug), { URI: urlparser_1.parseUri(debug.URI) });
};
function debuggerListeners(h, debuggingMode, terminalId, ideId, requestUser, checkConflict = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const qs = {
            debuggingMode,
            requestUser,
            terminalId,
            ideId,
            checkConflict
        };
        const response = yield h.request("/sap/bc/adt/debugger/listeners", { qs });
        if (!response.body)
            return;
        const raw = utilities_1.fullParse(response.body, { ignoreNameSpace: true });
        return parseDebugError(raw);
    });
}
exports.debuggerListeners = debuggerListeners;
function debuggerListen(h, debuggingMode, terminalId, ideId, requestUser, checkConflict = true, isNotifiedOnConflict = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const qs = {
            debuggingMode,
            requestUser,
            terminalId,
            ideId,
            checkConflict,
            isNotifiedOnConflict
        };
        const response = yield h.request("/sap/bc/adt/debugger/listeners", {
            method: "POST",
            timeout: 360000000,
            qs
        });
        return parseDebugListeners(response.body);
    });
}
exports.debuggerListen = debuggerListen;
function debuggerDeleteListener(h, debuggingMode, terminalId, ideId, requestUser) {
    return __awaiter(this, void 0, void 0, function* () {
        const qs = {
            debuggingMode,
            requestUser,
            terminalId,
            ideId,
            checkConflict: false,
            notifyConflict: true
        };
        yield h.request("/sap/bc/adt/debugger/listeners", { method: "DELETE", qs });
    });
}
exports.debuggerDeleteListener = debuggerDeleteListener;
const formatBreakpoint = (clientId) => (b) => {
    if (utilities_1.isString(b))
        return `<breakpoint xmlns:adtcore="http://www.sap.com/adt/core" kind="line" clientId="${clientId}" skipCount="0" adtcore:uri="${b}"/>`;
    const uri = `adtcore:uri="${b.uri.uri}#start=${b.uri.range.start.line}"`;
    const condition = b.condition ? `condition="${b.condition}"` : ``;
    return `<breakpoint xmlns:adtcore="http://www.sap.com/adt/core" kind="${b.kind}" clientId="${b.clientId}" skipCount="0" ${uri} ${condition}/>`;
};
const isDebuggerBreakpoint = (x) => "uri" in x;
exports.isDebuggerBreakpoint = isDebuggerBreakpoint;
function debuggerSetBreakpoints(h, debuggingMode, terminalId, ideId, clientId, breakpoints, requestUser, scope = "external", systemDebugging = false, deactivated = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = `<?xml version="1.0" encoding="UTF-8"?>
    <dbg:breakpoints scope="${scope}" debuggingMode="${debuggingMode}" requestUser="${requestUser}" 
        terminalId="${terminalId}" ideId="${ideId}" systemDebugging="${systemDebugging}" deactivated="${deactivated}"
        xmlns:dbg="http://www.sap.com/adt/debugger">
        <syncScope mode="full"></syncScope>
        ${breakpoints.map(formatBreakpoint(clientId)).join("")}
    </dbg:breakpoints>`;
        const headers = {
            "Content-Type": "application/xml",
            Accept: "application/xml"
        };
        const response = yield h.request("/sap/bc/adt/debugger/breakpoints", {
            method: "POST",
            headers,
            body
        });
        return parseBreakpoints(response.body);
    });
}
exports.debuggerSetBreakpoints = debuggerSetBreakpoints;
function debuggerDeleteBreakpoints(h, breakpoint, debuggingMode, terminalId, ideId, requestUser, scope = "external") {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/xml" };
        const qs = { scope, debuggingMode, requestUser, terminalId, ideId };
        yield h.request(`/sap/bc/adt/debugger/breakpoints/${encodeURIComponent(breakpoint.id)}`, {
            method: "DELETE",
            headers,
            qs
        });
    });
}
exports.debuggerDeleteBreakpoints = debuggerDeleteBreakpoints;
function debuggerAttach(h, debuggingMode, debuggeeId, requestUser = "", dynproDebugging = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {
            Accept: "application/xml"
        };
        const qs = {
            method: "attach",
            debuggeeId,
            dynproDebugging,
            debuggingMode,
            requestUser
        };
        const response = yield h.request("/sap/bc/adt/debugger", {
            method: "POST",
            headers,
            qs
        });
        return parseAttach(response.body);
    });
}
exports.debuggerAttach = debuggerAttach;
function debuggerSaveSettings(h, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {
            "Content-Type": "application/xml",
            Accept: "application/xml"
        };
        const { systemDebugging = false, createExceptionObject = false, backgroundRFC = false, sharedObjectDebugging = false, showDataAging = true, updateDebugging = false } = settings;
        const body = `<?xml version="1.0" encoding="UTF-8"?>
    <dbg:settings xmlns:dbg="http://www.sap.com/adt/debugger" 
    systemDebugging="${systemDebugging}" createExceptionObject="${createExceptionObject}" 
    backgroundRFC="${backgroundRFC}" sharedObjectDebugging="${sharedObjectDebugging}" 
    showDataAging="${showDataAging}" updateDebugging="${updateDebugging}">
    </dbg:settings>`;
        const qs = { method: "setDebuggerSettings" };
        const response = yield h.request("/sap/bc/adt/debugger", {
            method: "POST",
            headers,
            body,
            qs
        });
        return parseDebugSettings(response.body);
    });
}
exports.debuggerSaveSettings = debuggerSaveSettings;
function debuggerStack(h, semanticURIs = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/xml" };
        const qs = { method: "getStack", emode: "_", semanticURIs };
        const response = yield h.request("/sap/bc/adt/debugger/stack", {
            headers,
            qs
        });
        return parseStack(response.body);
    });
}
exports.debuggerStack = debuggerStack;
function simpleDebuggerStack(h, semanticURIs = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/xml" };
        const qs = { method: "getStack", emode: "_", semanticURIs };
        const response = yield h.request("/sap/bc/adt/debugger", { headers, method: "POST", qs });
        return parseStack(response.body);
    });
}
exports.simpleDebuggerStack = simpleDebuggerStack;
function debuggerChildVariables(h, parents = ["@ROOT", "@DATAAGING"]) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {
            Accept: "application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.debugger.ChildVariables",
            "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.debugger.ChildVariables"
        };
        const hierarchies = parents.map(p => `<STPDA_ADT_VARIABLE_HIERARCHY><PARENT_ID>${utilities_1.encodeEntity(p)}</PARENT_ID></STPDA_ADT_VARIABLE_HIERARCHY>`);
        const body = `<?xml version="1.0" encoding="UTF-8" ?><asx:abap version="1.0" xmlns:asx="http://www.sap.com/abapxml"><asx:values><DATA>
    <HIERARCHIES>${hierarchies.join("")}</HIERARCHIES>
    </DATA></asx:values></asx:abap>`;
        const qs = { method: "getChildVariables" };
        const response = yield h.request("/sap/bc/adt/debugger", { method: "POST", headers, qs, body });
        return parseChildVariables(response.body);
    });
}
exports.debuggerChildVariables = debuggerChildVariables;
function debuggerVariables(h, parents) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {
            Accept: "application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.debugger.Variables",
            "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.debugger.Variables"
        };
        const mainBody = parents.map(p => `<STPDA_ADT_VARIABLE><ID>${utilities_1.encodeEntity(p)}</ID></STPDA_ADT_VARIABLE>`).join("");
        const body = `<?xml version="1.0" encoding="UTF-8" ?><asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0"><asx:values>
    <DATA>${mainBody}</DATA></asx:values></asx:abap>`;
        const qs = { method: "getVariables" };
        const response = yield h.request("/sap/bc/adt/debugger", { method: "POST", headers, qs, body });
        return parseVariables(response.body);
    });
}
exports.debuggerVariables = debuggerVariables;
function debuggerStep(h, method, uri) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/xml" };
        const response = yield h.request("/sap/bc/adt/debugger", { method: "POST", headers, qs: { method, uri } });
        return parseStep(response.body);
    });
}
exports.debuggerStep = debuggerStep;
function debuggerGoToStack(h, stackUri) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!stackUri.match(/^\/sap\/bc\/adt\/debugger\/stack\/type\/[\w]+\/position\/\d+$/))
            throw __1.adtException(`Invalid stack URL: ${stackUri}`);
        yield h.request(stackUri, { method: "PUT" });
    });
}
exports.debuggerGoToStack = debuggerGoToStack;
function debuggerGoToStackOld(h, position) {
    return __awaiter(this, void 0, void 0, function* () {
        const qs = { method: "setStackPosition", position };
        yield h.request(`/sap/bc/adt/debugger?method=setStackPosition&position=10`, { method: "POST", qs });
    });
}
exports.debuggerGoToStackOld = debuggerGoToStackOld;
function debuggerSetVariableValue(h, variableName, value) {
    return __awaiter(this, void 0, void 0, function* () {
        const qs = { variableName };
        const resp = yield h.request(`/sap/bc/adt/debugger?method=setVariableValue`, { method: "POST", qs, body: value });
        return resp.body;
    });
}
exports.debuggerSetVariableValue = debuggerSetVariableValue;
