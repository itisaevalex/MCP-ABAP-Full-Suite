"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpublishServiceBinding = exports.publishServiceBinding = exports.ddicRepositoryAccess = exports.ddicElement = exports.annotationDefinitions = exports.syntaxCheckCDS = void 0;
const utilities_1 = require("../utilities");
const syntax_1 = require("./syntax");
function syntaxCheckCDS(h, url, mainUrl, content) {
    return __awaiter(this, void 0, void 0, function* () {
        const artifacts = mainUrl && content
            ? `<chkrun:artifacts>
  <chkrun:artifact chkrun:contentType="text/plain; charset=utf-8" chkrun:uri="${mainUrl}">
      <chkrun:content>${utilities_1.btoa(content)}</chkrun:content>
  </chkrun:artifact>
</chkrun:artifacts>`
            : "";
        const response = yield h.request("/sap/bc/adt/checkruns?reporters=abapCheckRun", {
            method: "POST",
            headers: {
                "Content-Type": "application/vnd.sap.adt.checkobjects+xml",
                Accept: "application/vnd.sap.adt.checkmessages+xml"
            },
            body: `<?xml version="1.0" encoding="UTF-8"?>
<chkrun:checkObjectList xmlns:adtcore="http://www.sap.com/adt/core" xmlns:chkrun="http://www.sap.com/adt/checkrun">
  <chkrun:checkObject adtcore:uri="${url}" chkrun:version="active">${artifacts}</chkrun:checkObject>
</chkrun:checkObjectList>`
        });
        const raw = utilities_1.fullParse(response.body);
        return syntax_1.parseCheckResults(raw);
    });
}
exports.syntaxCheckCDS = syntaxCheckCDS;
function annotationDefinitions(h) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {
            Accept: "application/vnd.sap.adt.cds.annotation.definitions.v1+xml, application/vnd.sap.adt.cds.annotation.definitions.v2+xml"
        };
        const response = yield h.request("/sap/bc/adt/ddic/cds/annotation/definitions", { headers });
        const raw = utilities_1.fullParse(response.body);
        return utilities_1.xmlNode(raw, "cds:annotation", "cds:definitions");
    });
}
exports.annotationDefinitions = annotationDefinitions;
function parseDDICProps(raw) {
    const converted = utilities_1.xmlArray(raw, "abapsource:entry").reduce((prev, cur) => {
        const key = cur["@_abapsource:key"];
        const value = cur["#text"];
        prev[key] = value;
        return prev;
    }, {});
    const { ddicIsKey, ddicDataElement, ddicDataType, ddicLength, ddicDecimals, ddicHeading, ddicLabelShort, ddicLabelMedium, ddicLabelLong, ddicHeadingLength, ddicLabelShortLength, ddicLabelMediumLength, ddicLabelLongLength, parentName } = converted, rawanno = __rest(converted, ["ddicIsKey", "ddicDataElement", "ddicDataType", "ddicLength", "ddicDecimals", "ddicHeading", "ddicLabelShort", "ddicLabelMedium", "ddicLabelLong", "ddicHeadingLength", "ddicLabelShortLength", "ddicLabelMediumLength", "ddicLabelLongLength", "parentName"]);
    const elementProps = (ddicDataType || ddicDataType === "") && {
        ddicIsKey: !!ddicIsKey,
        ddicDataElement,
        ddicDataType,
        ddicLength,
        ddicDecimals,
        ddicHeading,
        ddicLabelShort,
        ddicLabelMedium,
        ddicLabelLong,
        ddicHeadingLength,
        ddicLabelShortLength,
        ddicLabelMediumLength,
        ddicLabelLongLength,
        parentName
    };
    const annotations = [];
    // tslint:disable-next-line: forin
    for (const key in rawanno) {
        const match = key.match(/annotation(Key|Value).([0-9]+)/);
        if (match && match.groups) {
            const mtype = match.groups[1];
            const idx = utilities_1.toInt(match.groups[2]);
            const anno = annotations[idx] || { key: "", value: "" };
            if (mtype === "Key")
                anno.key = rawanno[key];
            else
                anno.value = rawanno[key];
            annotations[idx] = anno;
        }
    }
    return {
        elementProps,
        annotations
    };
}
function parseDdicElement(raw) {
    const type = raw["@_adtcore:type"];
    const name = raw["@_adtcore:name"];
    const properties = parseDDICProps(raw["abapsource:properties"]);
    const children = utilities_1.xmlArray(raw, "abapsource:elementInfo").map(parseDdicElement);
    return { type, name, properties, children };
}
function ddicElement(h, path, getTargetForAssociation = false, getExtensionViews = true, getSecondaryObjects = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/vnd.sap.adt.elementinfo+xml" };
        const qs = utilities_1.formatQS({
            getTargetForAssociation,
            getExtensionViews,
            getSecondaryObjects,
            path
        });
        const uri = `/sap/bc/adt/ddic/ddl/elementinfo?${qs}`;
        const response = yield h.request(uri, { headers });
        const raw = utilities_1.fullParse(response.body);
        return parseDdicElement(raw["abapsource:elementInfo"]);
    });
}
exports.ddicElement = ddicElement;
function ddicRepositoryAccess(h, path) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/*" };
        const qs = utilities_1.isArray(path)
            ? utilities_1.formatQS({ requestScope: "all", path })
            : `datasource=${encodeURIComponent(path)}`;
        const url = `/sap/bc/adt/ddic/ddl/ddicrepositoryaccess?${qs}`;
        const response = yield h.request(url, { headers });
        const raw = utilities_1.fullParse(response.body);
        const records = raw["adtcore:objectReferences"]
            ? utilities_1.xmlArray(raw, "adtcore:objectReferences", "adtcore:objectReference")
            : utilities_1.xmlArray(raw, "ddl:ddlObjectReferences", "ddl:ddlObjectReference");
        return records.map(r => {
            const attr = utilities_1.xmlNodeAttr(r);
            return {
                uri: attr["adtcore:uri"] || "",
                type: attr["adtcore:type"] || "",
                name: attr["adtcore:name"] || "",
                path: attr["ddl:path"] || ""
            };
        });
    });
}
exports.ddicRepositoryAccess = ddicRepositoryAccess;
function publishUnpublishServiceBinding(h, base, name, version) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = { Accept: "application/*" };
        const qs = `servicename=${encodeURIComponent(name)}&serviceversion=${version}`;
        const url = `/sap/bc/adt/businessservices/odatav2/${base}?${qs}`;
        const body = `<adtcore:objectReferences xmlns:adtcore="http://www.sap.com/adt/core">
  <adtcore:objectReference adtcore:name="${name}"/>
  </adtcore:objectReferences>`;
        const response = yield h.request(url, { headers, method: "POST", body });
        const raw = utilities_1.fullParse(response.body);
        const data = utilities_1.xmlNode(raw, "asx:abap/asx:values/DATA");
        const severity = utilities_1.xmlNode(data, "SEVERITY");
        const shortText = utilities_1.xmlNode(data, "SHORT_TEXT");
        const longText = utilities_1.xmlNode(data, "LONG_TEXT");
        return { severity, shortText, longText };
    });
}
function publishServiceBinding(h, name, version) {
    return __awaiter(this, void 0, void 0, function* () {
        return publishUnpublishServiceBinding(h, "publishjobs", name, version);
    });
}
exports.publishServiceBinding = publishServiceBinding;
function unpublishServiceBinding(h, name, version) {
    return __awaiter(this, void 0, void 0, function* () {
        return publishUnpublishServiceBinding(h, "unpublishjobs", name, version);
    });
}
exports.unpublishServiceBinding = unpublishServiceBinding;
